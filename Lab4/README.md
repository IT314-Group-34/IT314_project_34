# Functional Points

| Sr. no. | Student Name | Student ID |
| --- | --- | --- |
| 1 | Aatman Shah | 202001064 |
| 2 | Fenil Dalwala | 202001130 |
| 3 | Aditya Nawal | 202001402 |
| 4 | Rohan Champaneri | 202001414 |
| 5 | Kashish Shroff | 202001425 |
| 6 | Het Patel | 202001434 |
| 7 | Parth Thakrar | 202001450 |
| 8 | Drashit Bhakhar | 202001453 |
| 9 | Nandini Parekh | 202001455 |
| 10 | Amol Patel | 202001456 |
| 11 | Smit Bhavsar | 202001464 |

# Tools, Technologies, and Frameworks

## The framework - Flutter

Few reasons why we have chosen flutter over others:

1. Cross-Platform Development: Flutter allows you to build apps for both Android and iOS platforms with a single codebase. This can help reduce development time and effort, especially for a group of students who may have limited resources and time.
2. UI Development: Flutter provides a rich set of UI components and tools that make building beautiful and responsive user interfaces easy. This would be particularly useful for a project where visual appeal is an important factor.
3. Fast Development: Flutter has a fast development cycle, with a hot reload and a range of debugging tools that can help speed up development. This is especially important for a project that is being done by students within a limited time frame.
4. Community Support: Flutter has a large and active community of developers, which can provide support and resources for the development of the project. This can help the team overcome any technical challenges and provide access to a wealth of knowledge and experience.
5. Google Support: Flutter is maintained by Google, which provides ongoing support and resources for the development of the framework. This ensures that the framework will continue to evolve and improve over time.

## NoSQL Database - Firebase

Few reasons why we have chosen firebase over others:

1. Real-time database: Firebase provides a real-time NoSQL database that can be accessed from any client, making it ideal for building real-time applications.
2. Scalability: Firebase is a fully managed platform that can scale automatically to handle large amounts of traffic and data, which makes it easy for developers to focus on building their applications rather than worrying about scaling and infrastructure.
3. Flexibility: Firebase offers a range of services that can be used independently or in combination with each other, allowing developers to choose the services that best meet their needs.
4. Ease of use: Firebase has a simple and intuitive interface that makes it easy for developers to set up and manage their backend infrastructure.
5. Security: Firebase provides a range of security features, such as data encryption and multi-factor authentication, to ensure that your application and data are secure.

## IDE - VSCode

Few reasons why we have chosen visual studio code over others:

1. Lightweight: VS Code is a lightweight IDE that runs quickly and smoothly on most operating systems.
2. Open-source: VS Code is an open-source IDE, which means it is free to use, modify, and distribute.
3. Cross-platform: VS Code is available on Windows, macOS, and Linux, making it a versatile IDE that can be used on different machines.
4. Customizable: VS Code has a rich set of extensions and plugins that can be used to customize the editor to fit specific development needs.
5. IntelliSense: VS Code has a powerful IntelliSense feature that provides intelligent code completion and suggestions as you type, making coding faster and more efficient.
6. Debugging: VS Code has a built-in debugger that can be used to debug code directly within the editor.
7. Git integration: VS Code has excellent Git integration that makes it easy to manage code versioning and collaborate with other developers.

# External Inputs:

1. Username
2. Email
3. Password
4. User input to update email and password
5. The user searches for and views information about real estate. 
6. The user requests contact details for real estate agents 
7. The user enters a neighborhood name to add it to their Wishlist.
8. User selects a neighborhood from their Wishlist to remove it
9. User requests to view their Wishlist from their profile page
10. Users access the filter feature to view neighborhoods according to particular criteria they enter into the filters, such as location, price range, square footage, etc. 
11. User choose to compare some neighborhoods according to his preference.
12. Admin clicks on the "Log out" button to log out.
13. admin click on the "Forgot password" link to reset their password.
14. admin adds new neighbourhoods.
15. admin updates existing neighbourhoods.  
16. Admin delete existing neighbourhoods. 
17. Save button to save all changes  
18. The admin requests contact details for real estate agents 
19. User can give rating on factors like location, prices, quality, cost of living, security by their experience of neighborhood & write about their experiences and views of house in review part.

# External Outputs:

1. Successful account creation.
2. Profile page
3. Error message
4. Wishlist with added neighborhoods is displayed to the user. 
5. Wishlist with removed neighborhoods is displayed to the user. 
6. User gets the contact information for the selected real estate agents.
7. The appropriate list of local real estate agents or websites that match the search criteria.
8. Appropriate a list of neighborhoods that match the user's selected filter criteria.
9. User get some recommended results of properties and neighborhoods about his past preferences.
10. Users get the comparison outcomes of two neighborhoods based on features, cost, and building quality.
11. Once the admin successfully adds or updates a neighborhood, the system should display a confirmation message to inform the admin of the action taken.
12. The system should send notification messages to users who have subscribed to updates for a particular neighborhood. 
13. View a list of all existing neighborhoods and their details. 
14. The system should provide appropriate error messages in case of any failures during the neighborhood addition or update process.
15. Website is under an update that will take a while.
16. Users can find a brief description of every feature in help. 
17. User views overall ratings of specific neighborhood.

# External Inquiry:

1. Forgot password functionality (resets the password) 
2. Compare these two neighborhoods
3. Validation of required information: The system may need to communicate with the user to validate that all required information has been provided before adding or updating a neighborhood.
4. User requests to view their Wishlist from their profile page.
5. The system should validate that all required information is provided before adding or updating a neighborhood. 
6. Secure storage in the database: The system may need to communicate with the database to securely store the neighborhood information.
7. Due to high traffic system breakdown (wait for some time)

# Internal Logical Files:

1. User account information file containing the user's unique username, password, saved preferences, and account details.
2. Database of real estate listings and pricing information. 
3. File containing search criteria and saved preferences for future searches.
4. User Wishlist containing a list of neighborhoods.
5. Contact history and communication with real estate agents. 
6. File containing the list of filter criteria available to the user. 
7. Neighborhood data file: This file would contain all the necessary details about each neighborhood, such as name, location, amenities, pricing, etc.
8. Validation rules file: This file would contain the validation rules that the system would use to ensure that all required information is provided before adding or updating a neighborhood
9. User search results file: This file would contain the information about each neighborhood that would be displayed in the search results for users.
10. Database interface: The system would need to interact with a database to store and retrieve neighborhood information securely.

# External Interface Files:

1. Google Maps integration

# Unadjusted FPs Count:

| Measurement Parameter | Count | Low | Average | High | Total |
| --- | --- | --- | --- | --- | --- |
| EI | 19 | **3** | 4 | 6 | 57 |
| EO | 17 | 4 | **5** | 7 | 85 |
| EQ | 7 | 3 | **4** | 6 | 28 |
| ILF | 10 | 7 | **10** | 15 | 100 |
| EIF | 1 | 5 | 7 | **10** | 10 |
|  |  |  |  | Count Total | **280** |

# Complexity adjustment factor:

### Rate Scale of Factors:

Rate the following aspects on a scale of 0-5 :-
0 - No influence
1 - Incidental
2 - Moderate
3 - Average
4 - Significant
5 - Essential

| Complexity Factor | Fi |
| --- | --- |
| Does the system require reliable backup and recovery ? | 3 |
| Are data communications required? | 4 |
| Are there distributed processing functions? | 1 |
| Is performance critical? | 5 |
| Will the system run in an existing, heavily utilized operational environment? | 2 |
| Does the system require on-line data entry? | 5 |
| Does the on-line data entry require the input transaction to be built over multiple screens or operations? | 4 |
| Are the master files updated on-line? | 4 |
| Are the inputs, outputs, files or inquiries complex? | 3 |
| Is the internal processing complex? | 3 |
| Is the code to be designed reusable? | 3 |
| Are conversion and installation included in the design? | 0 |
| Is the system designed for multiple installations in different organizations? | 0 |
| Is the application designed to facilitate change and ease of use by the user? | 5 |

| Sigma(Fi) | 42 |
| --- | --- |

<aside>
ℹ️ CAF = 0.65 + ( 0.01 * 42 ) = 1.07

</aside>

# Adjusted FPs Count:

### Adjusted function point count = Unadjusted function point count * Complexity adjustment factor

UFE = 280

CAF = 1.07

Adjusted FPs Count = 280 * 1.07 = 299.6

<aside>
ℹ️ Hence the final count of Functional points is 299.6.

</aside>